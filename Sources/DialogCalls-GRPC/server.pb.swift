// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: server.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Dialog_CALL_DIRECTION: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case inbound // = 1
  case outbound // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .inbound
    case 2: self = .outbound
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .inbound: return 1
    case .outbound: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Dialog_CALL_DIRECTION: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Dialog_CALL_DIRECTION] = [
    .unknown,
    .inbound,
    .outbound,
  ]
}

#endif  // swift(>=4.2)

/// ===============================================================================
///Signalling call state
///=============================================================================== 
public enum Dialog_CALL_STATE: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0

  /// Call is not yet delivered to participant
  case trying // = 1

  /// Outbound call is not answered, but has incomming media
  case progress // = 2

  /// Call is ringing on device
  case ringing // = 3

  /// Participants are connectetd
  case talking // = 4

  /// Call is finished
  case finished // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .trying
    case 2: self = .progress
    case 3: self = .ringing
    case 4: self = .talking
    case 5: self = .finished
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .trying: return 1
    case .progress: return 2
    case .ringing: return 3
    case .talking: return 4
    case .finished: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Dialog_CALL_STATE: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Dialog_CALL_STATE] = [
    .unknown,
    .trying,
    .progress,
    .ringing,
    .talking,
    .finished,
  ]
}

#endif  // swift(>=4.2)

/// ===============================================================================
///Call finished reason
///=============================================================================== 
public enum Dialog_DISPOSE_REASON: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0

  /// Some error occured
  case error // = 1

  /// Request is sent to call that does not exists
  case callDoesNotExists // = 2

  /// Request is sent to call that is already pickupd by another device
  case pickedUp // = 3

  /// Participants normally finished call
  case normal // = 4

  /// Participant transfered call to another participant/call
  case transfer // = 5

  /// Callee is not found
  case calleeNotFound // = 6

  /// Call was not answered
  case noAnswer // = 7

  /// Callee is busy
  case busy // = 8

  /// Callee rejected call
  case rejected // = 9

  /// Caller is disabled
  case callerDisabled // = 10

  /// Callee is disabled
  case calleeDisabled // = 11
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .error
    case 2: self = .callDoesNotExists
    case 3: self = .pickedUp
    case 4: self = .normal
    case 5: self = .transfer
    case 6: self = .calleeNotFound
    case 7: self = .noAnswer
    case 8: self = .busy
    case 9: self = .rejected
    case 10: self = .callerDisabled
    case 11: self = .calleeDisabled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .error: return 1
    case .callDoesNotExists: return 2
    case .pickedUp: return 3
    case .normal: return 4
    case .transfer: return 5
    case .calleeNotFound: return 6
    case .noAnswer: return 7
    case .busy: return 8
    case .rejected: return 9
    case .callerDisabled: return 10
    case .calleeDisabled: return 11
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Dialog_DISPOSE_REASON: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Dialog_DISPOSE_REASON] = [
    .unknown,
    .error,
    .callDoesNotExists,
    .pickedUp,
    .normal,
    .transfer,
    .calleeNotFound,
    .noAnswer,
    .busy,
    .rejected,
    .callerDisabled,
    .calleeDisabled,
  ]
}

#endif  // swift(>=4.2)

/// ===============================================================================
///Reason to finish incomming call
///=============================================================================== 
public enum Dialog_HANGUP_REASON: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0

  /// Some error occured
  case error // = 1

  /// Normal finished
  case normal // = 2

  /// Callee is busy
  case busy // = 3

  /// Callee rejects call
  case reject // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .error
    case 2: self = .normal
    case 3: self = .busy
    case 4: self = .reject
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .error: return 1
    case .normal: return 2
    case .busy: return 3
    case .reject: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Dialog_HANGUP_REASON: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Dialog_HANGUP_REASON] = [
    .unknown,
    .error,
    .normal,
    .busy,
    .reject,
  ]
}

#endif  // swift(>=4.2)

/// ===============================================================================
///ICE mode
///=============================================================================== 
public enum Dialog_ICE_SETTINGS: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0

  /// Do not send ice to server
  case none // = 1

  /// Use only relay candidates
  case relay // = 2

  /// Use all ice candidates
  case all // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .none
    case 2: self = .relay
    case 3: self = .all
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .none: return 1
    case .relay: return 2
    case .all: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Dialog_ICE_SETTINGS: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Dialog_ICE_SETTINGS] = [
    .unknown,
    .none,
    .relay,
    .all,
  ]
}

#endif  // swift(>=4.2)

/// ===============================================================================
///Always incrementing sequence
///=============================================================================== 
public struct Dialog_SeqModel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var a: Int64 = 0

  public var b: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Dialog_SeqValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Dialog_SeqModel {
    get {return _storage._value ?? Dialog_SeqModel()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ===============================================================================
///Common model for create and answer call with settings
///=============================================================================== 
public struct Dialog_ConnectToCallSuccessModel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var iceSettings: Dialog_ConnectToCallSuccessModel.IceSettingsModel {
    get {return _storage._iceSettings ?? Dialog_ConnectToCallSuccessModel.IceSettingsModel()}
    set {_uniqueStorage()._iceSettings = newValue}
  }
  /// Returns true if `iceSettings` has been explicitly set.
  public var hasIceSettings: Bool {return _storage._iceSettings != nil}
  /// Clears the value of `iceSettings`. Subsequent reads from it will return its default value.
  public mutating func clearIceSettings() {_uniqueStorage()._iceSettings = nil}

  public var features: Dialog_ConnectToCallSuccessModel.ConnectToCallSuccessFeaturesModel {
    get {return _storage._features ?? Dialog_ConnectToCallSuccessModel.ConnectToCallSuccessFeaturesModel()}
    set {_uniqueStorage()._features = newValue}
  }
  /// Returns true if `features` has been explicitly set.
  public var hasFeatures: Bool {return _storage._features != nil}
  /// Clears the value of `features`. Subsequent reads from it will return its default value.
  public mutating func clearFeatures() {_uniqueStorage()._features = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ===========================================================================
  ///Ice settings
  ///=========================================================================== 
  public struct IceSettingsModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var settings: Dialog_ICE_SETTINGS = .unknown

    public var iceServers: [Dialog_ConnectToCallSuccessModel.IceSettingsModel.IceServerModel] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// =======================================================================
    ///Ice server - turn/stun
    ///======================================================================= 
    public struct IceServerModel {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var username: String = String()

      public var password: String = String()

      public var urls: [String] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public struct ConnectToCallSuccessFeaturesModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var attendedTrasnfer: Bool = false

    public var unAttendedTrasnfer: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ===============================================================================
///SDP exchange
///=============================================================================== 
public struct Dialog_SdpModel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// content
  public var sdp: String = String()

  /// type
  public var type: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ===============================================================================
///Info to merge call on client
///=============================================================================== 
public struct Dialog_MergeCallModel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String = String()

  public var merge: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ===============================================================================
///Generate id in call context request
///=============================================================================== 
public struct Dialog_GenerateIdRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ===============================================================================
///Generate id in call context response
///=============================================================================== 
public struct Dialog_GenerateIdResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: OneOf_Result? {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  public var invalidRequest: String {
    get {
      if case .invalidRequest(let v)? = _storage._result {return v}
      return String()
    }
    set {_uniqueStorage()._result = .invalidRequest(newValue)}
  }

  public var error: Dialog_GenerateIdResponse.GenerateIdResponseErrorModel {
    get {
      if case .error(let v)? = _storage._result {return v}
      return Dialog_GenerateIdResponse.GenerateIdResponseErrorModel()
    }
    set {_uniqueStorage()._result = .error(newValue)}
  }

  public var success: Dialog_GenerateIdResponse.GenerateIdResponseSuccessModel {
    get {
      if case .success(let v)? = _storage._result {return v}
      return Dialog_GenerateIdResponse.GenerateIdResponseSuccessModel()
    }
    set {_uniqueStorage()._result = .success(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    case invalidRequest(String)
    case error(Dialog_GenerateIdResponse.GenerateIdResponseErrorModel)
    case success(Dialog_GenerateIdResponse.GenerateIdResponseSuccessModel)

  #if !swift(>=4.1)
    public static func ==(lhs: Dialog_GenerateIdResponse.OneOf_Result, rhs: Dialog_GenerateIdResponse.OneOf_Result) -> Bool {
      switch (lhs, rhs) {
      case (.invalidRequest(let l), .invalidRequest(let r)): return l == r
      case (.error(let l), .error(let r)): return l == r
      case (.success(let l), .success(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public struct GenerateIdResponseSuccessModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct GenerateIdResponseErrorModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// call is finished/pickuped/not exists
    public var reason: Dialog_DISPOSE_REASON = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ===============================================================================
///Create call request
///=============================================================================== 
public struct Dialog_CreateCallRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unique call identifier (UUID)
  public var callID: String = String()

  /// participant
  public var parameters: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ===============================================================================
///Create call response
///=============================================================================== 
public struct Dialog_CreateCallResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: OneOf_Result? {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  public var invalidRequest: String {
    get {
      if case .invalidRequest(let v)? = _storage._result {return v}
      return String()
    }
    set {_uniqueStorage()._result = .invalidRequest(newValue)}
  }

  public var error: Dialog_CreateCallResponse.CreateCallResponseErrorModel {
    get {
      if case .error(let v)? = _storage._result {return v}
      return Dialog_CreateCallResponse.CreateCallResponseErrorModel()
    }
    set {_uniqueStorage()._result = .error(newValue)}
  }

  public var success: Dialog_CreateCallResponse.CreateCallResponseSuccessModel {
    get {
      if case .success(let v)? = _storage._result {return v}
      return Dialog_CreateCallResponse.CreateCallResponseSuccessModel()
    }
    set {_uniqueStorage()._result = .success(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    case invalidRequest(String)
    case error(Dialog_CreateCallResponse.CreateCallResponseErrorModel)
    case success(Dialog_CreateCallResponse.CreateCallResponseSuccessModel)

  #if !swift(>=4.1)
    public static func ==(lhs: Dialog_CreateCallResponse.OneOf_Result, rhs: Dialog_CreateCallResponse.OneOf_Result) -> Bool {
      switch (lhs, rhs) {
      case (.invalidRequest(let l), .invalidRequest(let r)): return l == r
      case (.error(let l), .error(let r)): return l == r
      case (.success(let l), .success(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public struct CreateCallResponseSuccessModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var connect: Dialog_ConnectToCallSuccessModel {
      get {return _storage._connect ?? Dialog_ConnectToCallSuccessModel()}
      set {_uniqueStorage()._connect = newValue}
    }
    /// Returns true if `connect` has been explicitly set.
    public var hasConnect: Bool {return _storage._connect != nil}
    /// Clears the value of `connect`. Subsequent reads from it will return its default value.
    public mutating func clearConnect() {_uniqueStorage()._connect = nil}

    /// call may be merged with inbound call
    public var merge: Dialog_MergeCallModel {
      get {return _storage._merge ?? Dialog_MergeCallModel()}
      set {_uniqueStorage()._merge = newValue}
    }
    /// Returns true if `merge` has been explicitly set.
    public var hasMerge: Bool {return _storage._merge != nil}
    /// Clears the value of `merge`. Subsequent reads from it will return its default value.
    public mutating func clearMerge() {_uniqueStorage()._merge = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct CreateCallResponseErrorModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// call is finished/pickuped/not exists
    public var reason: Dialog_DISPOSE_REASON = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ===============================================================================
///Transfer call request
///=============================================================================== 
public struct Dialog_TransferCallRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unique call identifier (UUID)
  public var callID: String {
    get {return _storage._callID}
    set {_uniqueStorage()._callID = newValue}
  }

  /// call instance id
  public var instanceID: Int32 {
    get {return _storage._instanceID}
    set {_uniqueStorage()._instanceID = newValue}
  }

  public var transfer: Dialog_TransferCallRequest.TrasnferOneOfModel {
    get {return _storage._transfer ?? Dialog_TransferCallRequest.TrasnferOneOfModel()}
    set {_uniqueStorage()._transfer = newValue}
  }
  /// Returns true if `transfer` has been explicitly set.
  public var hasTransfer: Bool {return _storage._transfer != nil}
  /// Clears the value of `transfer`. Subsequent reads from it will return its default value.
  public mutating func clearTransfer() {_uniqueStorage()._transfer = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// particiapnt wrapper
  public struct TransferCallRequestParticipantModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var parameters: Dictionary<String,String> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct TrasnferOneOfModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// transfer to particiapnt (unattended transfer) or call (attended transfer)
    public var transfer: OneOf_Transfer? {
      get {return _storage._transfer}
      set {_uniqueStorage()._transfer = newValue}
    }

    public var callID: String {
      get {
        if case .callID(let v)? = _storage._transfer {return v}
        return String()
      }
      set {_uniqueStorage()._transfer = .callID(newValue)}
    }

    public var participant: Dialog_TransferCallRequest.TransferCallRequestParticipantModel {
      get {
        if case .participant(let v)? = _storage._transfer {return v}
        return Dialog_TransferCallRequest.TransferCallRequestParticipantModel()
      }
      set {_uniqueStorage()._transfer = .participant(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// transfer to particiapnt (unattended transfer) or call (attended transfer)
    public enum OneOf_Transfer: Equatable {
      case callID(String)
      case participant(Dialog_TransferCallRequest.TransferCallRequestParticipantModel)

    #if !swift(>=4.1)
      public static func ==(lhs: Dialog_TransferCallRequest.TrasnferOneOfModel.OneOf_Transfer, rhs: Dialog_TransferCallRequest.TrasnferOneOfModel.OneOf_Transfer) -> Bool {
        switch (lhs, rhs) {
        case (.callID(let l), .callID(let r)): return l == r
        case (.participant(let l), .participant(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ===============================================================================
///Transfer call response
///=============================================================================== 
public struct Dialog_TransferCallResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: OneOf_Result? {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  public var invalidRequest: String {
    get {
      if case .invalidRequest(let v)? = _storage._result {return v}
      return String()
    }
    set {_uniqueStorage()._result = .invalidRequest(newValue)}
  }

  public var error: Dialog_TransferCallResponse.TransferCallResponseErrorModel {
    get {
      if case .error(let v)? = _storage._result {return v}
      return Dialog_TransferCallResponse.TransferCallResponseErrorModel()
    }
    set {_uniqueStorage()._result = .error(newValue)}
  }

  public var success: Dialog_TransferCallResponse.TransferCallResponseSuccessModel {
    get {
      if case .success(let v)? = _storage._result {return v}
      return Dialog_TransferCallResponse.TransferCallResponseSuccessModel()
    }
    set {_uniqueStorage()._result = .success(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    case invalidRequest(String)
    case error(Dialog_TransferCallResponse.TransferCallResponseErrorModel)
    case success(Dialog_TransferCallResponse.TransferCallResponseSuccessModel)

  #if !swift(>=4.1)
    public static func ==(lhs: Dialog_TransferCallResponse.OneOf_Result, rhs: Dialog_TransferCallResponse.OneOf_Result) -> Bool {
      switch (lhs, rhs) {
      case (.invalidRequest(let l), .invalidRequest(let r)): return l == r
      case (.error(let l), .error(let r)): return l == r
      case (.success(let l), .success(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public struct TransferCallResponseSuccessModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct TransferCallResponseErrorModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// call is finished/pickuped/not exists
    public var reason: Dialog_DISPOSE_REASON = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ===============================================================================
///Call is rining on device request
///=============================================================================== 
public struct Dialog_RingingCallRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ===============================================================================
///Call is rining on device response
///=============================================================================== 
public struct Dialog_RingingCallResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: OneOf_Result? {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  public var invalidRequest: String {
    get {
      if case .invalidRequest(let v)? = _storage._result {return v}
      return String()
    }
    set {_uniqueStorage()._result = .invalidRequest(newValue)}
  }

  public var error: Dialog_RingingCallResponse.RingingCallResponseErrorModel {
    get {
      if case .error(let v)? = _storage._result {return v}
      return Dialog_RingingCallResponse.RingingCallResponseErrorModel()
    }
    set {_uniqueStorage()._result = .error(newValue)}
  }

  public var success: Dialog_RingingCallResponse.RingingCallResponseSuccessModel {
    get {
      if case .success(let v)? = _storage._result {return v}
      return Dialog_RingingCallResponse.RingingCallResponseSuccessModel()
    }
    set {_uniqueStorage()._result = .success(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    case invalidRequest(String)
    case error(Dialog_RingingCallResponse.RingingCallResponseErrorModel)
    case success(Dialog_RingingCallResponse.RingingCallResponseSuccessModel)

  #if !swift(>=4.1)
    public static func ==(lhs: Dialog_RingingCallResponse.OneOf_Result, rhs: Dialog_RingingCallResponse.OneOf_Result) -> Bool {
      switch (lhs, rhs) {
      case (.invalidRequest(let l), .invalidRequest(let r)): return l == r
      case (.error(let l), .error(let r)): return l == r
      case (.success(let l), .success(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public struct RingingCallResponseSuccessModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct RingingCallResponseErrorModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// call is finished/pickuped/not exists
    public var reason: Dialog_DISPOSE_REASON = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ===============================================================================
///Puckup call on device request
///=============================================================================== 
public struct Dialog_AnswerCallRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  /// call instance id
  public var instanceID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ===============================================================================
///Puckup call on device response
///=============================================================================== 
public struct Dialog_AnswerCallResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: OneOf_Result? {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  public var invalidRequest: String {
    get {
      if case .invalidRequest(let v)? = _storage._result {return v}
      return String()
    }
    set {_uniqueStorage()._result = .invalidRequest(newValue)}
  }

  public var error: Dialog_AnswerCallResponse.AnswerCallResponseErrorModel {
    get {
      if case .error(let v)? = _storage._result {return v}
      return Dialog_AnswerCallResponse.AnswerCallResponseErrorModel()
    }
    set {_uniqueStorage()._result = .error(newValue)}
  }

  public var success: Dialog_AnswerCallResponse.AnswerCallResponseSuccessModel {
    get {
      if case .success(let v)? = _storage._result {return v}
      return Dialog_AnswerCallResponse.AnswerCallResponseSuccessModel()
    }
    set {_uniqueStorage()._result = .success(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    case invalidRequest(String)
    case error(Dialog_AnswerCallResponse.AnswerCallResponseErrorModel)
    case success(Dialog_AnswerCallResponse.AnswerCallResponseSuccessModel)

  #if !swift(>=4.1)
    public static func ==(lhs: Dialog_AnswerCallResponse.OneOf_Result, rhs: Dialog_AnswerCallResponse.OneOf_Result) -> Bool {
      switch (lhs, rhs) {
      case (.invalidRequest(let l), .invalidRequest(let r)): return l == r
      case (.error(let l), .error(let r)): return l == r
      case (.success(let l), .success(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public struct AnswerCallResponseSuccessModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var connect: Dialog_ConnectToCallSuccessModel {
      get {return _storage._connect ?? Dialog_ConnectToCallSuccessModel()}
      set {_uniqueStorage()._connect = newValue}
    }
    /// Returns true if `connect` has been explicitly set.
    public var hasConnect: Bool {return _storage._connect != nil}
    /// Clears the value of `connect`. Subsequent reads from it will return its default value.
    public mutating func clearConnect() {_uniqueStorage()._connect = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct AnswerCallResponseErrorModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// call is finished/pickuped/not exists
    public var reason: Dialog_DISPOSE_REASON = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ===============================================================================
///Finish call request
///=============================================================================== 
public struct Dialog_DisposeCallRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String {
    get {return _storage._callID}
    set {_uniqueStorage()._callID = newValue}
  }

  /// call instance id
  public var instanceID: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._instanceID ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._instanceID = newValue}
  }
  /// Returns true if `instanceID` has been explicitly set.
  public var hasInstanceID: Bool {return _storage._instanceID != nil}
  /// Clears the value of `instanceID`. Subsequent reads from it will return its default value.
  public mutating func clearInstanceID() {_uniqueStorage()._instanceID = nil}

  public var reason: Dialog_HANGUP_REASON {
    get {return _storage._reason}
    set {_uniqueStorage()._reason = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ===============================================================================
///Finish call response
///=============================================================================== 
public struct Dialog_DisposeCallResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: OneOf_Result? {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  public var invalidRequest: String {
    get {
      if case .invalidRequest(let v)? = _storage._result {return v}
      return String()
    }
    set {_uniqueStorage()._result = .invalidRequest(newValue)}
  }

  public var error: Dialog_DisposeCallResponse.DisposeCallResponseErrorModel {
    get {
      if case .error(let v)? = _storage._result {return v}
      return Dialog_DisposeCallResponse.DisposeCallResponseErrorModel()
    }
    set {_uniqueStorage()._result = .error(newValue)}
  }

  public var success: Dialog_DisposeCallResponse.DisposeCallResponseSuccessModel {
    get {
      if case .success(let v)? = _storage._result {return v}
      return Dialog_DisposeCallResponse.DisposeCallResponseSuccessModel()
    }
    set {_uniqueStorage()._result = .success(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    case invalidRequest(String)
    case error(Dialog_DisposeCallResponse.DisposeCallResponseErrorModel)
    case success(Dialog_DisposeCallResponse.DisposeCallResponseSuccessModel)

  #if !swift(>=4.1)
    public static func ==(lhs: Dialog_DisposeCallResponse.OneOf_Result, rhs: Dialog_DisposeCallResponse.OneOf_Result) -> Bool {
      switch (lhs, rhs) {
      case (.invalidRequest(let l), .invalidRequest(let r)): return l == r
      case (.error(let l), .error(let r)): return l == r
      case (.success(let l), .success(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public struct DisposeCallResponseSuccessModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct DisposeCallResponseErrorModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ===============================================================================
///Request permission to renegotiate request
///=============================================================================== 
public struct Dialog_LockCallRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  /// call instance id
  public var instanceID: Int32 = 0

  /// peer connection id
  public var peerConnectionID: Int32 = 0

  /// session description id
  public var sdpID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ===============================================================================
///Request permission to renegotiate response
///=============================================================================== 
public struct Dialog_LockCallResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: OneOf_Result? {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  public var invalidRequest: String {
    get {
      if case .invalidRequest(let v)? = _storage._result {return v}
      return String()
    }
    set {_uniqueStorage()._result = .invalidRequest(newValue)}
  }

  public var error: Dialog_LockCallResponse.LockCallResponseErrorModel {
    get {
      if case .error(let v)? = _storage._result {return v}
      return Dialog_LockCallResponse.LockCallResponseErrorModel()
    }
    set {_uniqueStorage()._result = .error(newValue)}
  }

  public var success: Dialog_LockCallResponse.LockCallResponseSuccessModel {
    get {
      if case .success(let v)? = _storage._result {return v}
      return Dialog_LockCallResponse.LockCallResponseSuccessModel()
    }
    set {_uniqueStorage()._result = .success(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    case invalidRequest(String)
    case error(Dialog_LockCallResponse.LockCallResponseErrorModel)
    case success(Dialog_LockCallResponse.LockCallResponseSuccessModel)

  #if !swift(>=4.1)
    public static func ==(lhs: Dialog_LockCallResponse.OneOf_Result, rhs: Dialog_LockCallResponse.OneOf_Result) -> Bool {
      switch (lhs, rhs) {
      case (.invalidRequest(let l), .invalidRequest(let r)): return l == r
      case (.error(let l), .error(let r)): return l == r
      case (.success(let l), .success(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public struct LockCallResponseSuccessModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var locked: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct LockCallResponseErrorModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// call is finished/pickuped/not exists
    public var reason: Dialog_DISPOSE_REASON = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ===============================================================================
///Send session description request
///=============================================================================== 
public struct Dialog_JoinCallRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String {
    get {return _storage._callID}
    set {_uniqueStorage()._callID = newValue}
  }

  /// call instance id
  public var instanceID: Int32 {
    get {return _storage._instanceID}
    set {_uniqueStorage()._instanceID = newValue}
  }

  /// peer connection id
  public var peerConnectionID: Int32 {
    get {return _storage._peerConnectionID}
    set {_uniqueStorage()._peerConnectionID = newValue}
  }

  /// session description id
  public var sdpID: Int32 {
    get {return _storage._sdpID}
    set {_uniqueStorage()._sdpID = newValue}
  }

  /// session description
  public var sdp: Dialog_SdpModel {
    get {return _storage._sdp ?? Dialog_SdpModel()}
    set {_uniqueStorage()._sdp = newValue}
  }
  /// Returns true if `sdp` has been explicitly set.
  public var hasSdp: Bool {return _storage._sdp != nil}
  /// Clears the value of `sdp`. Subsequent reads from it will return its default value.
  public mutating func clearSdp() {_uniqueStorage()._sdp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ===============================================================================
///Send session description response
///=============================================================================== 
public struct Dialog_JoinCallResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: OneOf_Result? {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  public var invalidRequest: String {
    get {
      if case .invalidRequest(let v)? = _storage._result {return v}
      return String()
    }
    set {_uniqueStorage()._result = .invalidRequest(newValue)}
  }

  public var error: Dialog_JoinCallResponse.JoinCallResponseErrorModel {
    get {
      if case .error(let v)? = _storage._result {return v}
      return Dialog_JoinCallResponse.JoinCallResponseErrorModel()
    }
    set {_uniqueStorage()._result = .error(newValue)}
  }

  public var success: Dialog_JoinCallResponse.JoinCallResponseSuccessModel {
    get {
      if case .success(let v)? = _storage._result {return v}
      return Dialog_JoinCallResponse.JoinCallResponseSuccessModel()
    }
    set {_uniqueStorage()._result = .success(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    case invalidRequest(String)
    case error(Dialog_JoinCallResponse.JoinCallResponseErrorModel)
    case success(Dialog_JoinCallResponse.JoinCallResponseSuccessModel)

  #if !swift(>=4.1)
    public static func ==(lhs: Dialog_JoinCallResponse.OneOf_Result, rhs: Dialog_JoinCallResponse.OneOf_Result) -> Bool {
      switch (lhs, rhs) {
      case (.invalidRequest(let l), .invalidRequest(let r)): return l == r
      case (.error(let l), .error(let r)): return l == r
      case (.success(let l), .success(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public struct JoinCallResponseSuccessModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct JoinCallResponseErrorModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// call is finished/pickuped/not exists
    public var reason: Dialog_DISPOSE_REASON = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ===============================================================================
///Send ice candidates request
///=============================================================================== 
public struct Dialog_IceCallRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  /// call instance id
  public var instanceID: Int32 = 0

  public var ices: [Dialog_IceCallRequest.IceCallRequestCandidateItemModel] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct IceCallRequestCandidateItemModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// peer connection id
    public var peerConnectionID: Int32 {
      get {return _storage._peerConnectionID}
      set {_uniqueStorage()._peerConnectionID = newValue}
    }

    /// session description id
    public var sdpID: Int32 {
      get {return _storage._sdpID}
      set {_uniqueStorage()._sdpID = newValue}
    }

    /// ice candidate id
    public var iceID: Int32 {
      get {return _storage._iceID}
      set {_uniqueStorage()._iceID = newValue}
    }

    /// session description type
    public var sdpType: String {
      get {return _storage._sdpType}
      set {_uniqueStorage()._sdpType = newValue}
    }

    /// ice candidate
    public var ice: Dialog_IceCallRequest.IceCallRequestCandidateItemModel.IceCandidateModel {
      get {return _storage._ice ?? Dialog_IceCallRequest.IceCallRequestCandidateItemModel.IceCandidateModel()}
      set {_uniqueStorage()._ice = newValue}
    }
    /// Returns true if `ice` has been explicitly set.
    public var hasIce: Bool {return _storage._ice != nil}
    /// Clears the value of `ice`. Subsequent reads from it will return its default value.
    public mutating func clearIce() {_uniqueStorage()._ice = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct IceCandidateModel {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var candidate: String = String()

      public var sdpMid: String = String()

      public var sdpMlineIndex: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

/// ===============================================================================
///Send ice candidates response
///=============================================================================== 
public struct Dialog_IceCallResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: OneOf_Result? {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  public var invalidRequest: String {
    get {
      if case .invalidRequest(let v)? = _storage._result {return v}
      return String()
    }
    set {_uniqueStorage()._result = .invalidRequest(newValue)}
  }

  public var error: Dialog_IceCallResponse.IceCallResponseErrorModel {
    get {
      if case .error(let v)? = _storage._result {return v}
      return Dialog_IceCallResponse.IceCallResponseErrorModel()
    }
    set {_uniqueStorage()._result = .error(newValue)}
  }

  public var success: Dialog_IceCallResponse.IceCallResponseSuccessModel {
    get {
      if case .success(let v)? = _storage._result {return v}
      return Dialog_IceCallResponse.IceCallResponseSuccessModel()
    }
    set {_uniqueStorage()._result = .success(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    case invalidRequest(String)
    case error(Dialog_IceCallResponse.IceCallResponseErrorModel)
    case success(Dialog_IceCallResponse.IceCallResponseSuccessModel)

  #if !swift(>=4.1)
    public static func ==(lhs: Dialog_IceCallResponse.OneOf_Result, rhs: Dialog_IceCallResponse.OneOf_Result) -> Bool {
      switch (lhs, rhs) {
      case (.invalidRequest(let l), .invalidRequest(let r)): return l == r
      case (.error(let l), .error(let r)): return l == r
      case (.success(let l), .success(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public struct IceCallResponseSuccessModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct IceCallResponseErrorModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// call is finished/pickuped/not exists
    public var reason: Dialog_DISPOSE_REASON = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ===============================================================================
///Server message received notification requesat
///=============================================================================== 
public struct Dialog_AckRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// server message identifier
  public var seq: Dialog_SeqModel {
    get {return _storage._seq ?? Dialog_SeqModel()}
    set {_uniqueStorage()._seq = newValue}
  }
  /// Returns true if `seq` has been explicitly set.
  public var hasSeq: Bool {return _storage._seq != nil}
  /// Clears the value of `seq`. Subsequent reads from it will return its default value.
  public mutating func clearSeq() {_uniqueStorage()._seq = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ===============================================================================
///Server message received notification response
///=============================================================================== 
public struct Dialog_AckResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ===============================================================================
///Open stream request
///=============================================================================== 
public struct Dialog_ConnectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ===============================================================================
///Open stream response
///=============================================================================== 
public struct Dialog_ConnectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// message unique id
  public var seq: Dialog_SeqModel {
    get {return _storage._seq ?? Dialog_SeqModel()}
    set {_uniqueStorage()._seq = newValue}
  }
  /// Returns true if `seq` has been explicitly set.
  public var hasSeq: Bool {return _storage._seq != nil}
  /// Clears the value of `seq`. Subsequent reads from it will return its default value.
  public mutating func clearSeq() {_uniqueStorage()._seq = nil}

  public var data: OneOf_Data? {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  /// user active calls
  public var calls: Dialog_ConnectResponse.ConnectResponseServerCallListModel {
    get {
      if case .calls(let v)? = _storage._data {return v}
      return Dialog_ConnectResponse.ConnectResponseServerCallListModel()
    }
    set {_uniqueStorage()._data = .calls(newValue)}
  }

  /// call was disposed
  public var dispose: Dialog_ConnectResponse.ConnectResponseDisposeCallModel {
    get {
      if case .dispose(let v)? = _storage._data {return v}
      return Dialog_ConnectResponse.ConnectResponseDisposeCallModel()
    }
    set {_uniqueStorage()._data = .dispose(newValue)}
  }

  /// call has join to process
  public var join: Dialog_ConnectResponse.ConnectResponseJoinCallModel {
    get {
      if case .join(let v)? = _storage._data {return v}
      return Dialog_ConnectResponse.ConnectResponseJoinCallModel()
    }
    set {_uniqueStorage()._data = .join(newValue)}
  }

  /// call has ice to process
  public var ice: Dialog_ConnectResponse.ConnectResponseIceCallModel {
    get {
      if case .ice(let v)? = _storage._data {return v}
      return Dialog_ConnectResponse.ConnectResponseIceCallModel()
    }
    set {_uniqueStorage()._data = .ice(newValue)}
  }

  /// call needed to be renegotiated from client
  public var renegotiate: Dialog_ConnectResponse.ConnectResponseRenegotiateCallModel {
    get {
      if case .renegotiate(let v)? = _storage._data {return v}
      return Dialog_ConnectResponse.ConnectResponseRenegotiateCallModel()
    }
    set {_uniqueStorage()._data = .renegotiate(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable {
    /// user active calls
    case calls(Dialog_ConnectResponse.ConnectResponseServerCallListModel)
    /// call was disposed
    case dispose(Dialog_ConnectResponse.ConnectResponseDisposeCallModel)
    /// call has join to process
    case join(Dialog_ConnectResponse.ConnectResponseJoinCallModel)
    /// call has ice to process
    case ice(Dialog_ConnectResponse.ConnectResponseIceCallModel)
    /// call needed to be renegotiated from client
    case renegotiate(Dialog_ConnectResponse.ConnectResponseRenegotiateCallModel)

  #if !swift(>=4.1)
    public static func ==(lhs: Dialog_ConnectResponse.OneOf_Data, rhs: Dialog_ConnectResponse.OneOf_Data) -> Bool {
      switch (lhs, rhs) {
      case (.calls(let l), .calls(let r)): return l == r
      case (.dispose(let l), .dispose(let r)): return l == r
      case (.join(let l), .join(let r)): return l == r
      case (.ice(let l), .ice(let r)): return l == r
      case (.renegotiate(let l), .renegotiate(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public struct ConnectResponseServerCallListModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var calls: [Dialog_ConnectResponse.ConnectResponseServerCallListModel.ConnectResponseServerCallListItemModel] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// =======================================================================
    ///Active call model
    ///======================================================================= 
    public struct ConnectResponseServerCallListItemModel {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// incrementing call state sequence
      public var stateID: Int32 {
        get {return _storage._stateID}
        set {_uniqueStorage()._stateID = newValue}
      }

      /// callId
      public var callID: String {
        get {return _storage._callID}
        set {_uniqueStorage()._callID = newValue}
      }

      /// current instance id
      public var instanceID: SwiftProtobuf.Google_Protobuf_Int32Value {
        get {return _storage._instanceID ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
        set {_uniqueStorage()._instanceID = newValue}
      }
      /// Returns true if `instanceID` has been explicitly set.
      public var hasInstanceID: Bool {return _storage._instanceID != nil}
      /// Clears the value of `instanceID`. Subsequent reads from it will return its default value.
      public mutating func clearInstanceID() {_uniqueStorage()._instanceID = nil}

      /// signaling state
      public var state: Dialog_CALL_STATE {
        get {return _storage._state}
        set {_uniqueStorage()._state = newValue}
      }

      /// direction
      public var direction: Dialog_CALL_DIRECTION {
        get {return _storage._direction}
        set {_uniqueStorage()._direction = newValue}
      }

      /// call is/was active on current device
      public var currentDevice: Bool {
        get {return _storage._currentDevice}
        set {_uniqueStorage()._currentDevice = newValue}
      }

      /// call was answered at
      public var answerDateUtc: SwiftProtobuf.Google_Protobuf_Int64Value {
        get {return _storage._answerDateUtc ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
        set {_uniqueStorage()._answerDateUtc = newValue}
      }
      /// Returns true if `answerDateUtc` has been explicitly set.
      public var hasAnswerDateUtc: Bool {return _storage._answerDateUtc != nil}
      /// Clears the value of `answerDateUtc`. Subsequent reads from it will return its default value.
      public mutating func clearAnswerDateUtc() {_uniqueStorage()._answerDateUtc = nil}

      /// call has video
      public var video: Bool {
        get {return _storage._video}
        set {_uniqueStorage()._video = newValue}
      }

      /// call parameters from client or router
      public var parameters: Dictionary<String,String> {
        get {return _storage._parameters}
        set {_uniqueStorage()._parameters = newValue}
      }

      /// call may be merged with;
      public var merge: Dialog_MergeCallModel {
        get {return _storage._merge ?? Dialog_MergeCallModel()}
        set {_uniqueStorage()._merge = newValue}
      }
      /// Returns true if `merge` has been explicitly set.
      public var hasMerge: Bool {return _storage._merge != nil}
      /// Clears the value of `merge`. Subsequent reads from it will return its default value.
      public mutating func clearMerge() {_uniqueStorage()._merge = nil}

      public var groupCallID: SwiftProtobuf.Google_Protobuf_StringValue {
        get {return _storage._groupCallID ?? SwiftProtobuf.Google_Protobuf_StringValue()}
        set {_uniqueStorage()._groupCallID = newValue}
      }
      /// Returns true if `groupCallID` has been explicitly set.
      public var hasGroupCallID: Bool {return _storage._groupCallID != nil}
      /// Clears the value of `groupCallID`. Subsequent reads from it will return its default value.
      public mutating func clearGroupCallID() {_uniqueStorage()._groupCallID = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    public init() {}
  }

  public struct ConnectResponseDisposeCallModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var callID: String {
      get {return _storage._callID}
      set {_uniqueStorage()._callID = newValue}
    }

    public var instanceID: SwiftProtobuf.Google_Protobuf_Int32Value {
      get {return _storage._instanceID ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
      set {_uniqueStorage()._instanceID = newValue}
    }
    /// Returns true if `instanceID` has been explicitly set.
    public var hasInstanceID: Bool {return _storage._instanceID != nil}
    /// Clears the value of `instanceID`. Subsequent reads from it will return its default value.
    public mutating func clearInstanceID() {_uniqueStorage()._instanceID = nil}

    public var reason: Dialog_DISPOSE_REASON {
      get {return _storage._reason}
      set {_uniqueStorage()._reason = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct ConnectResponseJoinCallModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var join: Dialog_JoinCallRequest {
      get {return _storage._join ?? Dialog_JoinCallRequest()}
      set {_uniqueStorage()._join = newValue}
    }
    /// Returns true if `join` has been explicitly set.
    public var hasJoin: Bool {return _storage._join != nil}
    /// Clears the value of `join`. Subsequent reads from it will return its default value.
    public mutating func clearJoin() {_uniqueStorage()._join = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct ConnectResponseIceCallModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var ice: Dialog_IceCallRequest {
      get {return _storage._ice ?? Dialog_IceCallRequest()}
      set {_uniqueStorage()._ice = newValue}
    }
    /// Returns true if `ice` has been explicitly set.
    public var hasIce: Bool {return _storage._ice != nil}
    /// Clears the value of `ice`. Subsequent reads from it will return its default value.
    public mutating func clearIce() {_uniqueStorage()._ice = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct ConnectResponseRenegotiateCallModel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var callID: String {
      get {return _storage._callID}
      set {_uniqueStorage()._callID = newValue}
    }

    public var instanceID: Int32 {
      get {return _storage._instanceID}
      set {_uniqueStorage()._instanceID = newValue}
    }

    public var peerConnectionID: Int32 {
      get {return _storage._peerConnectionID}
      set {_uniqueStorage()._peerConnectionID = newValue}
    }

    public var sdpID: SwiftProtobuf.Google_Protobuf_Int32Value {
      get {return _storage._sdpID ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
      set {_uniqueStorage()._sdpID = newValue}
    }
    /// Returns true if `sdpID` has been explicitly set.
    public var hasSdpID: Bool {return _storage._sdpID != nil}
    /// Clears the value of `sdpID`. Subsequent reads from it will return its default value.
    public mutating func clearSdpID() {_uniqueStorage()._sdpID = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "im.dlg.sdk.calls.client.p2p.api"

extension Dialog_CALL_DIRECTION: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CALL_DIRECTION_UNKNOWN"),
    1: .same(proto: "CALL_DIRECTION_INBOUND"),
    2: .same(proto: "CALL_DIRECTION_OUTBOUND"),
  ]
}

extension Dialog_CALL_STATE: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CALL_STATE_UNKNOWN"),
    1: .same(proto: "CALL_STATE_TRYING"),
    2: .same(proto: "CALL_STATE_PROGRESS"),
    3: .same(proto: "CALL_STATE_RINGING"),
    4: .same(proto: "CALL_STATE_TALKING"),
    5: .same(proto: "CALL_STATE_FINISHED"),
  ]
}

extension Dialog_DISPOSE_REASON: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISPOSE_REASON_UNKNOWN"),
    1: .same(proto: "DISPOSE_REASON_ERROR"),
    2: .same(proto: "DISPOSE_REASON_CALL_DOES_NOT_EXISTS"),
    3: .same(proto: "DISPOSE_REASON_PICKED_UP"),
    4: .same(proto: "DISPOSE_REASON_NORMAL"),
    5: .same(proto: "DISPOSE_REASON_TRANSFER"),
    6: .same(proto: "DISPOSE_REASON_CALLEE_NOT_FOUND"),
    7: .same(proto: "DISPOSE_REASON_NO_ANSWER"),
    8: .same(proto: "DISPOSE_REASON_BUSY"),
    9: .same(proto: "DISPOSE_REASON_REJECTED"),
    10: .same(proto: "DISPOSE_REASON_CALLER_DISABLED"),
    11: .same(proto: "DISPOSE_REASON_CALLEE_DISABLED"),
  ]
}

extension Dialog_HANGUP_REASON: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HANGUP_REASON_UNKNOWN"),
    1: .same(proto: "HANGUP_REASON_ERROR"),
    2: .same(proto: "HANGUP_REASON_NORMAL"),
    3: .same(proto: "HANGUP_REASON_BUSY"),
    4: .same(proto: "HANGUP_REASON_REJECT"),
  ]
}

extension Dialog_ICE_SETTINGS: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ICE_SETTINGS_UNKNOWN"),
    1: .same(proto: "ICE_SETTINGS_NONE"),
    2: .same(proto: "ICE_SETTINGS_RELAY"),
    3: .same(proto: "ICE_SETTINGS_ALL"),
  ]
}

extension Dialog_SeqModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SeqModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "a"),
    2: .same(proto: "b"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.a)
      case 2: try decoder.decodeSingularInt64Field(value: &self.b)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.a != 0 {
      try visitor.visitSingularInt64Field(value: self.a, fieldNumber: 1)
    }
    if self.b != 0 {
      try visitor.visitSingularInt64Field(value: self.b, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_SeqModel, rhs: Dialog_SeqModel) -> Bool {
    if lhs.a != rhs.a {return false}
    if lhs.b != rhs.b {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_SeqValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SeqValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  fileprivate class _StorageClass {
    var _value: Dialog_SeqModel? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._value)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_SeqValue, rhs: Dialog_SeqValue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_ConnectToCallSuccessModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectToCallSuccessModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "iceSettings"),
    2: .same(proto: "features"),
  ]

  fileprivate class _StorageClass {
    var _iceSettings: Dialog_ConnectToCallSuccessModel.IceSettingsModel? = nil
    var _features: Dialog_ConnectToCallSuccessModel.ConnectToCallSuccessFeaturesModel? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _iceSettings = source._iceSettings
      _features = source._features
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._iceSettings)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._features)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._iceSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._features {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_ConnectToCallSuccessModel, rhs: Dialog_ConnectToCallSuccessModel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._iceSettings != rhs_storage._iceSettings {return false}
        if _storage._features != rhs_storage._features {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_ConnectToCallSuccessModel.IceSettingsModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_ConnectToCallSuccessModel.protoMessageName + ".IceSettingsModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "settings"),
    2: .same(proto: "iceServers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.settings)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.iceServers)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.settings != .unknown {
      try visitor.visitSingularEnumField(value: self.settings, fieldNumber: 1)
    }
    if !self.iceServers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.iceServers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_ConnectToCallSuccessModel.IceSettingsModel, rhs: Dialog_ConnectToCallSuccessModel.IceSettingsModel) -> Bool {
    if lhs.settings != rhs.settings {return false}
    if lhs.iceServers != rhs.iceServers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_ConnectToCallSuccessModel.IceSettingsModel.IceServerModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_ConnectToCallSuccessModel.IceSettingsModel.protoMessageName + ".IceServerModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "password"),
    3: .same(proto: "urls"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.username)
      case 2: try decoder.decodeSingularStringField(value: &self.password)
      case 3: try decoder.decodeRepeatedStringField(value: &self.urls)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.urls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.urls, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_ConnectToCallSuccessModel.IceSettingsModel.IceServerModel, rhs: Dialog_ConnectToCallSuccessModel.IceSettingsModel.IceServerModel) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.urls != rhs.urls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_ConnectToCallSuccessModel.ConnectToCallSuccessFeaturesModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_ConnectToCallSuccessModel.protoMessageName + ".ConnectToCallSuccessFeaturesModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attendedTrasnfer"),
    2: .same(proto: "unAttendedTrasnfer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.attendedTrasnfer)
      case 2: try decoder.decodeSingularBoolField(value: &self.unAttendedTrasnfer)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.attendedTrasnfer != false {
      try visitor.visitSingularBoolField(value: self.attendedTrasnfer, fieldNumber: 1)
    }
    if self.unAttendedTrasnfer != false {
      try visitor.visitSingularBoolField(value: self.unAttendedTrasnfer, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_ConnectToCallSuccessModel.ConnectToCallSuccessFeaturesModel, rhs: Dialog_ConnectToCallSuccessModel.ConnectToCallSuccessFeaturesModel) -> Bool {
    if lhs.attendedTrasnfer != rhs.attendedTrasnfer {return false}
    if lhs.unAttendedTrasnfer != rhs.unAttendedTrasnfer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_SdpModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SdpModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sdp"),
    2: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.sdp)
      case 2: try decoder.decodeSingularStringField(value: &self.type)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sdp.isEmpty {
      try visitor.visitSingularStringField(value: self.sdp, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_SdpModel, rhs: Dialog_SdpModel) -> Bool {
    if lhs.sdp != rhs.sdp {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_MergeCallModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MergeCallModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "merge"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.key)
      case 2: try decoder.decodeSingularBoolField(value: &self.merge)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if self.merge != false {
      try visitor.visitSingularBoolField(value: self.merge, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_MergeCallModel, rhs: Dialog_MergeCallModel) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.merge != rhs.merge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_GenerateIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateIdRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.callID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_GenerateIdRequest, rhs: Dialog_GenerateIdRequest) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_GenerateIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateIdResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invalidRequest"),
    2: .same(proto: "error"),
    3: .same(proto: "success"),
  ]

  fileprivate class _StorageClass {
    var _result: Dialog_GenerateIdResponse.OneOf_Result?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _result = source._result
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._result != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._result = .invalidRequest(v)}
        case 2:
          var v: Dialog_GenerateIdResponse.GenerateIdResponseErrorModel?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .error(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .error(v)}
        case 3:
          var v: Dialog_GenerateIdResponse.GenerateIdResponseSuccessModel?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .success(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .success(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._result {
      case .invalidRequest(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      case .error(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .success(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_GenerateIdResponse, rhs: Dialog_GenerateIdResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._result != rhs_storage._result {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_GenerateIdResponse.GenerateIdResponseSuccessModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_GenerateIdResponse.protoMessageName + ".GenerateIdResponseSuccessModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.id)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_GenerateIdResponse.GenerateIdResponseSuccessModel, rhs: Dialog_GenerateIdResponse.GenerateIdResponseSuccessModel) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_GenerateIdResponse.GenerateIdResponseErrorModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_GenerateIdResponse.protoMessageName + ".GenerateIdResponseErrorModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.reason)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_GenerateIdResponse.GenerateIdResponseErrorModel, rhs: Dialog_GenerateIdResponse.GenerateIdResponseErrorModel) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_CreateCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateCallRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
    2: .same(proto: "parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.callID)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.parameters)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if !self.parameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.parameters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_CreateCallRequest, rhs: Dialog_CreateCallRequest) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_CreateCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateCallResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invalidRequest"),
    2: .same(proto: "error"),
    3: .same(proto: "success"),
  ]

  fileprivate class _StorageClass {
    var _result: Dialog_CreateCallResponse.OneOf_Result?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _result = source._result
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._result != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._result = .invalidRequest(v)}
        case 2:
          var v: Dialog_CreateCallResponse.CreateCallResponseErrorModel?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .error(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .error(v)}
        case 3:
          var v: Dialog_CreateCallResponse.CreateCallResponseSuccessModel?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .success(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .success(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._result {
      case .invalidRequest(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      case .error(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .success(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_CreateCallResponse, rhs: Dialog_CreateCallResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._result != rhs_storage._result {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_CreateCallResponse.CreateCallResponseSuccessModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_CreateCallResponse.protoMessageName + ".CreateCallResponseSuccessModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connect"),
    2: .same(proto: "merge"),
  ]

  fileprivate class _StorageClass {
    var _connect: Dialog_ConnectToCallSuccessModel? = nil
    var _merge: Dialog_MergeCallModel? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _connect = source._connect
      _merge = source._merge
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._connect)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._merge)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._connect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._merge {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_CreateCallResponse.CreateCallResponseSuccessModel, rhs: Dialog_CreateCallResponse.CreateCallResponseSuccessModel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._connect != rhs_storage._connect {return false}
        if _storage._merge != rhs_storage._merge {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_CreateCallResponse.CreateCallResponseErrorModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_CreateCallResponse.protoMessageName + ".CreateCallResponseErrorModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.reason)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_CreateCallResponse.CreateCallResponseErrorModel, rhs: Dialog_CreateCallResponse.CreateCallResponseErrorModel) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_TransferCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransferCallRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
    2: .same(proto: "instanceId"),
    3: .same(proto: "transfer"),
  ]

  fileprivate class _StorageClass {
    var _callID: String = String()
    var _instanceID: Int32 = 0
    var _transfer: Dialog_TransferCallRequest.TrasnferOneOfModel? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _callID = source._callID
      _instanceID = source._instanceID
      _transfer = source._transfer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._callID)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._instanceID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._transfer)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._callID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._callID, fieldNumber: 1)
      }
      if _storage._instanceID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._instanceID, fieldNumber: 2)
      }
      if let v = _storage._transfer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_TransferCallRequest, rhs: Dialog_TransferCallRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._callID != rhs_storage._callID {return false}
        if _storage._instanceID != rhs_storage._instanceID {return false}
        if _storage._transfer != rhs_storage._transfer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_TransferCallRequest.TransferCallRequestParticipantModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_TransferCallRequest.protoMessageName + ".TransferCallRequestParticipantModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.parameters)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.parameters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_TransferCallRequest.TransferCallRequestParticipantModel, rhs: Dialog_TransferCallRequest.TransferCallRequestParticipantModel) -> Bool {
    if lhs.parameters != rhs.parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_TransferCallRequest.TrasnferOneOfModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_TransferCallRequest.protoMessageName + ".TrasnferOneOfModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
    2: .same(proto: "participant"),
  ]

  fileprivate class _StorageClass {
    var _transfer: Dialog_TransferCallRequest.TrasnferOneOfModel.OneOf_Transfer?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transfer = source._transfer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._transfer != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._transfer = .callID(v)}
        case 2:
          var v: Dialog_TransferCallRequest.TransferCallRequestParticipantModel?
          if let current = _storage._transfer {
            try decoder.handleConflictingOneOf()
            if case .participant(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._transfer = .participant(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._transfer {
      case .callID(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      case .participant(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_TransferCallRequest.TrasnferOneOfModel, rhs: Dialog_TransferCallRequest.TrasnferOneOfModel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transfer != rhs_storage._transfer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_TransferCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransferCallResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invalidRequest"),
    2: .same(proto: "error"),
    3: .same(proto: "success"),
  ]

  fileprivate class _StorageClass {
    var _result: Dialog_TransferCallResponse.OneOf_Result?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _result = source._result
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._result != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._result = .invalidRequest(v)}
        case 2:
          var v: Dialog_TransferCallResponse.TransferCallResponseErrorModel?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .error(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .error(v)}
        case 3:
          var v: Dialog_TransferCallResponse.TransferCallResponseSuccessModel?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .success(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .success(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._result {
      case .invalidRequest(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      case .error(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .success(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_TransferCallResponse, rhs: Dialog_TransferCallResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._result != rhs_storage._result {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_TransferCallResponse.TransferCallResponseSuccessModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_TransferCallResponse.protoMessageName + ".TransferCallResponseSuccessModel"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_TransferCallResponse.TransferCallResponseSuccessModel, rhs: Dialog_TransferCallResponse.TransferCallResponseSuccessModel) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_TransferCallResponse.TransferCallResponseErrorModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_TransferCallResponse.protoMessageName + ".TransferCallResponseErrorModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.reason)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_TransferCallResponse.TransferCallResponseErrorModel, rhs: Dialog_TransferCallResponse.TransferCallResponseErrorModel) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_RingingCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RingingCallRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.callID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_RingingCallRequest, rhs: Dialog_RingingCallRequest) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_RingingCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RingingCallResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invalidRequest"),
    2: .same(proto: "error"),
    3: .same(proto: "success"),
  ]

  fileprivate class _StorageClass {
    var _result: Dialog_RingingCallResponse.OneOf_Result?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _result = source._result
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._result != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._result = .invalidRequest(v)}
        case 2:
          var v: Dialog_RingingCallResponse.RingingCallResponseErrorModel?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .error(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .error(v)}
        case 3:
          var v: Dialog_RingingCallResponse.RingingCallResponseSuccessModel?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .success(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .success(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._result {
      case .invalidRequest(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      case .error(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .success(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_RingingCallResponse, rhs: Dialog_RingingCallResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._result != rhs_storage._result {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_RingingCallResponse.RingingCallResponseSuccessModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_RingingCallResponse.protoMessageName + ".RingingCallResponseSuccessModel"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_RingingCallResponse.RingingCallResponseSuccessModel, rhs: Dialog_RingingCallResponse.RingingCallResponseSuccessModel) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_RingingCallResponse.RingingCallResponseErrorModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_RingingCallResponse.protoMessageName + ".RingingCallResponseErrorModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.reason)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_RingingCallResponse.RingingCallResponseErrorModel, rhs: Dialog_RingingCallResponse.RingingCallResponseErrorModel) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_AnswerCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnswerCallRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
    2: .same(proto: "instanceId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.callID)
      case 2: try decoder.decodeSingularInt32Field(value: &self.instanceID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.instanceID != 0 {
      try visitor.visitSingularInt32Field(value: self.instanceID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_AnswerCallRequest, rhs: Dialog_AnswerCallRequest) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.instanceID != rhs.instanceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_AnswerCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnswerCallResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invalidRequest"),
    2: .same(proto: "error"),
    3: .same(proto: "success"),
  ]

  fileprivate class _StorageClass {
    var _result: Dialog_AnswerCallResponse.OneOf_Result?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _result = source._result
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._result != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._result = .invalidRequest(v)}
        case 2:
          var v: Dialog_AnswerCallResponse.AnswerCallResponseErrorModel?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .error(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .error(v)}
        case 3:
          var v: Dialog_AnswerCallResponse.AnswerCallResponseSuccessModel?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .success(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .success(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._result {
      case .invalidRequest(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      case .error(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .success(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_AnswerCallResponse, rhs: Dialog_AnswerCallResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._result != rhs_storage._result {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_AnswerCallResponse.AnswerCallResponseSuccessModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_AnswerCallResponse.protoMessageName + ".AnswerCallResponseSuccessModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connect"),
  ]

  fileprivate class _StorageClass {
    var _connect: Dialog_ConnectToCallSuccessModel? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _connect = source._connect
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._connect)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._connect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_AnswerCallResponse.AnswerCallResponseSuccessModel, rhs: Dialog_AnswerCallResponse.AnswerCallResponseSuccessModel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._connect != rhs_storage._connect {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_AnswerCallResponse.AnswerCallResponseErrorModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_AnswerCallResponse.protoMessageName + ".AnswerCallResponseErrorModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.reason)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_AnswerCallResponse.AnswerCallResponseErrorModel, rhs: Dialog_AnswerCallResponse.AnswerCallResponseErrorModel) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_DisposeCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisposeCallRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
    2: .same(proto: "instanceId"),
    3: .same(proto: "reason"),
  ]

  fileprivate class _StorageClass {
    var _callID: String = String()
    var _instanceID: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _reason: Dialog_HANGUP_REASON = .unknown

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _callID = source._callID
      _instanceID = source._instanceID
      _reason = source._reason
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._callID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._instanceID)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._reason)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._callID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._callID, fieldNumber: 1)
      }
      if let v = _storage._instanceID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._reason != .unknown {
        try visitor.visitSingularEnumField(value: _storage._reason, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_DisposeCallRequest, rhs: Dialog_DisposeCallRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._callID != rhs_storage._callID {return false}
        if _storage._instanceID != rhs_storage._instanceID {return false}
        if _storage._reason != rhs_storage._reason {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_DisposeCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisposeCallResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invalidRequest"),
    2: .same(proto: "error"),
    3: .same(proto: "success"),
  ]

  fileprivate class _StorageClass {
    var _result: Dialog_DisposeCallResponse.OneOf_Result?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _result = source._result
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._result != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._result = .invalidRequest(v)}
        case 2:
          var v: Dialog_DisposeCallResponse.DisposeCallResponseErrorModel?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .error(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .error(v)}
        case 3:
          var v: Dialog_DisposeCallResponse.DisposeCallResponseSuccessModel?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .success(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .success(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._result {
      case .invalidRequest(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      case .error(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .success(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_DisposeCallResponse, rhs: Dialog_DisposeCallResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._result != rhs_storage._result {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_DisposeCallResponse.DisposeCallResponseSuccessModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_DisposeCallResponse.protoMessageName + ".DisposeCallResponseSuccessModel"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_DisposeCallResponse.DisposeCallResponseSuccessModel, rhs: Dialog_DisposeCallResponse.DisposeCallResponseSuccessModel) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_DisposeCallResponse.DisposeCallResponseErrorModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_DisposeCallResponse.protoMessageName + ".DisposeCallResponseErrorModel"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_DisposeCallResponse.DisposeCallResponseErrorModel, rhs: Dialog_DisposeCallResponse.DisposeCallResponseErrorModel) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_LockCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LockCallRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
    2: .same(proto: "instanceId"),
    3: .same(proto: "peerConnectionId"),
    4: .same(proto: "sdpId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.callID)
      case 2: try decoder.decodeSingularInt32Field(value: &self.instanceID)
      case 3: try decoder.decodeSingularInt32Field(value: &self.peerConnectionID)
      case 4: try decoder.decodeSingularInt32Field(value: &self.sdpID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.instanceID != 0 {
      try visitor.visitSingularInt32Field(value: self.instanceID, fieldNumber: 2)
    }
    if self.peerConnectionID != 0 {
      try visitor.visitSingularInt32Field(value: self.peerConnectionID, fieldNumber: 3)
    }
    if self.sdpID != 0 {
      try visitor.visitSingularInt32Field(value: self.sdpID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_LockCallRequest, rhs: Dialog_LockCallRequest) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.instanceID != rhs.instanceID {return false}
    if lhs.peerConnectionID != rhs.peerConnectionID {return false}
    if lhs.sdpID != rhs.sdpID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_LockCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LockCallResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invalidRequest"),
    2: .same(proto: "error"),
    3: .same(proto: "success"),
  ]

  fileprivate class _StorageClass {
    var _result: Dialog_LockCallResponse.OneOf_Result?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _result = source._result
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._result != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._result = .invalidRequest(v)}
        case 2:
          var v: Dialog_LockCallResponse.LockCallResponseErrorModel?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .error(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .error(v)}
        case 3:
          var v: Dialog_LockCallResponse.LockCallResponseSuccessModel?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .success(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .success(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._result {
      case .invalidRequest(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      case .error(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .success(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_LockCallResponse, rhs: Dialog_LockCallResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._result != rhs_storage._result {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_LockCallResponse.LockCallResponseSuccessModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_LockCallResponse.protoMessageName + ".LockCallResponseSuccessModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locked"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.locked)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.locked != false {
      try visitor.visitSingularBoolField(value: self.locked, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_LockCallResponse.LockCallResponseSuccessModel, rhs: Dialog_LockCallResponse.LockCallResponseSuccessModel) -> Bool {
    if lhs.locked != rhs.locked {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_LockCallResponse.LockCallResponseErrorModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_LockCallResponse.protoMessageName + ".LockCallResponseErrorModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.reason)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_LockCallResponse.LockCallResponseErrorModel, rhs: Dialog_LockCallResponse.LockCallResponseErrorModel) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_JoinCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinCallRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
    2: .same(proto: "instanceId"),
    3: .same(proto: "peerConnectionId"),
    4: .same(proto: "sdpId"),
    5: .same(proto: "sdp"),
  ]

  fileprivate class _StorageClass {
    var _callID: String = String()
    var _instanceID: Int32 = 0
    var _peerConnectionID: Int32 = 0
    var _sdpID: Int32 = 0
    var _sdp: Dialog_SdpModel? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _callID = source._callID
      _instanceID = source._instanceID
      _peerConnectionID = source._peerConnectionID
      _sdpID = source._sdpID
      _sdp = source._sdp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._callID)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._instanceID)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._peerConnectionID)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._sdpID)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._sdp)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._callID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._callID, fieldNumber: 1)
      }
      if _storage._instanceID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._instanceID, fieldNumber: 2)
      }
      if _storage._peerConnectionID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._peerConnectionID, fieldNumber: 3)
      }
      if _storage._sdpID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._sdpID, fieldNumber: 4)
      }
      if let v = _storage._sdp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_JoinCallRequest, rhs: Dialog_JoinCallRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._callID != rhs_storage._callID {return false}
        if _storage._instanceID != rhs_storage._instanceID {return false}
        if _storage._peerConnectionID != rhs_storage._peerConnectionID {return false}
        if _storage._sdpID != rhs_storage._sdpID {return false}
        if _storage._sdp != rhs_storage._sdp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_JoinCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinCallResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invalidRequest"),
    2: .same(proto: "error"),
    3: .same(proto: "success"),
  ]

  fileprivate class _StorageClass {
    var _result: Dialog_JoinCallResponse.OneOf_Result?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _result = source._result
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._result != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._result = .invalidRequest(v)}
        case 2:
          var v: Dialog_JoinCallResponse.JoinCallResponseErrorModel?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .error(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .error(v)}
        case 3:
          var v: Dialog_JoinCallResponse.JoinCallResponseSuccessModel?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .success(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .success(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._result {
      case .invalidRequest(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      case .error(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .success(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_JoinCallResponse, rhs: Dialog_JoinCallResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._result != rhs_storage._result {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_JoinCallResponse.JoinCallResponseSuccessModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_JoinCallResponse.protoMessageName + ".JoinCallResponseSuccessModel"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_JoinCallResponse.JoinCallResponseSuccessModel, rhs: Dialog_JoinCallResponse.JoinCallResponseSuccessModel) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_JoinCallResponse.JoinCallResponseErrorModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_JoinCallResponse.protoMessageName + ".JoinCallResponseErrorModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.reason)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_JoinCallResponse.JoinCallResponseErrorModel, rhs: Dialog_JoinCallResponse.JoinCallResponseErrorModel) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_IceCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IceCallRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
    2: .same(proto: "instanceId"),
    3: .same(proto: "ices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.callID)
      case 2: try decoder.decodeSingularInt32Field(value: &self.instanceID)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.ices)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.instanceID != 0 {
      try visitor.visitSingularInt32Field(value: self.instanceID, fieldNumber: 2)
    }
    if !self.ices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ices, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_IceCallRequest, rhs: Dialog_IceCallRequest) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.instanceID != rhs.instanceID {return false}
    if lhs.ices != rhs.ices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_IceCallRequest.IceCallRequestCandidateItemModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_IceCallRequest.protoMessageName + ".IceCallRequestCandidateItemModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "peerConnectionId"),
    2: .same(proto: "sdpId"),
    3: .same(proto: "iceId"),
    4: .same(proto: "sdpType"),
    5: .same(proto: "ice"),
  ]

  fileprivate class _StorageClass {
    var _peerConnectionID: Int32 = 0
    var _sdpID: Int32 = 0
    var _iceID: Int32 = 0
    var _sdpType: String = String()
    var _ice: Dialog_IceCallRequest.IceCallRequestCandidateItemModel.IceCandidateModel? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _peerConnectionID = source._peerConnectionID
      _sdpID = source._sdpID
      _iceID = source._iceID
      _sdpType = source._sdpType
      _ice = source._ice
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._peerConnectionID)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._sdpID)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._iceID)
        case 4: try decoder.decodeSingularStringField(value: &_storage._sdpType)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._ice)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._peerConnectionID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._peerConnectionID, fieldNumber: 1)
      }
      if _storage._sdpID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._sdpID, fieldNumber: 2)
      }
      if _storage._iceID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._iceID, fieldNumber: 3)
      }
      if !_storage._sdpType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sdpType, fieldNumber: 4)
      }
      if let v = _storage._ice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_IceCallRequest.IceCallRequestCandidateItemModel, rhs: Dialog_IceCallRequest.IceCallRequestCandidateItemModel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._peerConnectionID != rhs_storage._peerConnectionID {return false}
        if _storage._sdpID != rhs_storage._sdpID {return false}
        if _storage._iceID != rhs_storage._iceID {return false}
        if _storage._sdpType != rhs_storage._sdpType {return false}
        if _storage._ice != rhs_storage._ice {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_IceCallRequest.IceCallRequestCandidateItemModel.IceCandidateModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_IceCallRequest.IceCallRequestCandidateItemModel.protoMessageName + ".IceCandidateModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "candidate"),
    2: .same(proto: "sdpMid"),
    3: .same(proto: "sdpMLineIndex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.candidate)
      case 2: try decoder.decodeSingularStringField(value: &self.sdpMid)
      case 3: try decoder.decodeSingularInt32Field(value: &self.sdpMlineIndex)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.candidate.isEmpty {
      try visitor.visitSingularStringField(value: self.candidate, fieldNumber: 1)
    }
    if !self.sdpMid.isEmpty {
      try visitor.visitSingularStringField(value: self.sdpMid, fieldNumber: 2)
    }
    if self.sdpMlineIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.sdpMlineIndex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_IceCallRequest.IceCallRequestCandidateItemModel.IceCandidateModel, rhs: Dialog_IceCallRequest.IceCallRequestCandidateItemModel.IceCandidateModel) -> Bool {
    if lhs.candidate != rhs.candidate {return false}
    if lhs.sdpMid != rhs.sdpMid {return false}
    if lhs.sdpMlineIndex != rhs.sdpMlineIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_IceCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IceCallResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invalidRequest"),
    2: .same(proto: "error"),
    3: .same(proto: "success"),
  ]

  fileprivate class _StorageClass {
    var _result: Dialog_IceCallResponse.OneOf_Result?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _result = source._result
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._result != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._result = .invalidRequest(v)}
        case 2:
          var v: Dialog_IceCallResponse.IceCallResponseErrorModel?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .error(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .error(v)}
        case 3:
          var v: Dialog_IceCallResponse.IceCallResponseSuccessModel?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .success(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .success(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._result {
      case .invalidRequest(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      case .error(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .success(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_IceCallResponse, rhs: Dialog_IceCallResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._result != rhs_storage._result {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_IceCallResponse.IceCallResponseSuccessModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_IceCallResponse.protoMessageName + ".IceCallResponseSuccessModel"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_IceCallResponse.IceCallResponseSuccessModel, rhs: Dialog_IceCallResponse.IceCallResponseSuccessModel) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_IceCallResponse.IceCallResponseErrorModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_IceCallResponse.protoMessageName + ".IceCallResponseErrorModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.reason)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_IceCallResponse.IceCallResponseErrorModel, rhs: Dialog_IceCallResponse.IceCallResponseErrorModel) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_AckRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AckRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seq"),
  ]

  fileprivate class _StorageClass {
    var _seq: Dialog_SeqModel? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _seq = source._seq
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._seq)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._seq {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_AckRequest, rhs: Dialog_AckRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._seq != rhs_storage._seq {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_AckResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AckResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_AckResponse, rhs: Dialog_AckResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_ConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_ConnectRequest, rhs: Dialog_ConnectRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_ConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seq"),
    2: .same(proto: "calls"),
    3: .same(proto: "dispose"),
    4: .same(proto: "join"),
    5: .same(proto: "ice"),
    6: .same(proto: "renegotiate"),
  ]

  fileprivate class _StorageClass {
    var _seq: Dialog_SeqModel? = nil
    var _data: Dialog_ConnectResponse.OneOf_Data?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _seq = source._seq
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._seq)
        case 2:
          var v: Dialog_ConnectResponse.ConnectResponseServerCallListModel?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .calls(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .calls(v)}
        case 3:
          var v: Dialog_ConnectResponse.ConnectResponseDisposeCallModel?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .dispose(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .dispose(v)}
        case 4:
          var v: Dialog_ConnectResponse.ConnectResponseJoinCallModel?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .join(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .join(v)}
        case 5:
          var v: Dialog_ConnectResponse.ConnectResponseIceCallModel?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .ice(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .ice(v)}
        case 6:
          var v: Dialog_ConnectResponse.ConnectResponseRenegotiateCallModel?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .renegotiate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .renegotiate(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._seq {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      switch _storage._data {
      case .calls(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .dispose(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .join(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .ice(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .renegotiate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_ConnectResponse, rhs: Dialog_ConnectResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._seq != rhs_storage._seq {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_ConnectResponse.ConnectResponseServerCallListModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_ConnectResponse.protoMessageName + ".ConnectResponseServerCallListModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "calls"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeRepeatedMessageField(value: &self.calls)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.calls.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.calls, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_ConnectResponse.ConnectResponseServerCallListModel, rhs: Dialog_ConnectResponse.ConnectResponseServerCallListModel) -> Bool {
    if lhs.calls != rhs.calls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_ConnectResponse.ConnectResponseServerCallListModel.ConnectResponseServerCallListItemModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_ConnectResponse.ConnectResponseServerCallListModel.protoMessageName + ".ConnectResponseServerCallListItemModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stateId"),
    2: .same(proto: "callId"),
    3: .same(proto: "instanceId"),
    4: .same(proto: "state"),
    5: .same(proto: "direction"),
    6: .same(proto: "currentDevice"),
    7: .same(proto: "answerDateUTC"),
    8: .same(proto: "video"),
    9: .same(proto: "parameters"),
    10: .same(proto: "merge"),
    11: .same(proto: "groupCallId"),
  ]

  fileprivate class _StorageClass {
    var _stateID: Int32 = 0
    var _callID: String = String()
    var _instanceID: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _state: Dialog_CALL_STATE = .unknown
    var _direction: Dialog_CALL_DIRECTION = .unknown
    var _currentDevice: Bool = false
    var _answerDateUtc: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    var _video: Bool = false
    var _parameters: Dictionary<String,String> = [:]
    var _merge: Dialog_MergeCallModel? = nil
    var _groupCallID: SwiftProtobuf.Google_Protobuf_StringValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _stateID = source._stateID
      _callID = source._callID
      _instanceID = source._instanceID
      _state = source._state
      _direction = source._direction
      _currentDevice = source._currentDevice
      _answerDateUtc = source._answerDateUtc
      _video = source._video
      _parameters = source._parameters
      _merge = source._merge
      _groupCallID = source._groupCallID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._stateID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._callID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._instanceID)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._state)
        case 5: try decoder.decodeSingularEnumField(value: &_storage._direction)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._currentDevice)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._answerDateUtc)
        case 8: try decoder.decodeSingularBoolField(value: &_storage._video)
        case 9: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._parameters)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._merge)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._groupCallID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._stateID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._stateID, fieldNumber: 1)
      }
      if !_storage._callID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._callID, fieldNumber: 2)
      }
      if let v = _storage._instanceID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._state != .unknown {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 4)
      }
      if _storage._direction != .unknown {
        try visitor.visitSingularEnumField(value: _storage._direction, fieldNumber: 5)
      }
      if _storage._currentDevice != false {
        try visitor.visitSingularBoolField(value: _storage._currentDevice, fieldNumber: 6)
      }
      if let v = _storage._answerDateUtc {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if _storage._video != false {
        try visitor.visitSingularBoolField(value: _storage._video, fieldNumber: 8)
      }
      if !_storage._parameters.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._parameters, fieldNumber: 9)
      }
      if let v = _storage._merge {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._groupCallID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_ConnectResponse.ConnectResponseServerCallListModel.ConnectResponseServerCallListItemModel, rhs: Dialog_ConnectResponse.ConnectResponseServerCallListModel.ConnectResponseServerCallListItemModel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._stateID != rhs_storage._stateID {return false}
        if _storage._callID != rhs_storage._callID {return false}
        if _storage._instanceID != rhs_storage._instanceID {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._direction != rhs_storage._direction {return false}
        if _storage._currentDevice != rhs_storage._currentDevice {return false}
        if _storage._answerDateUtc != rhs_storage._answerDateUtc {return false}
        if _storage._video != rhs_storage._video {return false}
        if _storage._parameters != rhs_storage._parameters {return false}
        if _storage._merge != rhs_storage._merge {return false}
        if _storage._groupCallID != rhs_storage._groupCallID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_ConnectResponse.ConnectResponseDisposeCallModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_ConnectResponse.protoMessageName + ".ConnectResponseDisposeCallModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
    2: .same(proto: "instanceId"),
    3: .same(proto: "reason"),
  ]

  fileprivate class _StorageClass {
    var _callID: String = String()
    var _instanceID: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _reason: Dialog_DISPOSE_REASON = .unknown

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _callID = source._callID
      _instanceID = source._instanceID
      _reason = source._reason
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._callID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._instanceID)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._reason)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._callID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._callID, fieldNumber: 1)
      }
      if let v = _storage._instanceID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._reason != .unknown {
        try visitor.visitSingularEnumField(value: _storage._reason, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_ConnectResponse.ConnectResponseDisposeCallModel, rhs: Dialog_ConnectResponse.ConnectResponseDisposeCallModel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._callID != rhs_storage._callID {return false}
        if _storage._instanceID != rhs_storage._instanceID {return false}
        if _storage._reason != rhs_storage._reason {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_ConnectResponse.ConnectResponseJoinCallModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_ConnectResponse.protoMessageName + ".ConnectResponseJoinCallModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "join"),
  ]

  fileprivate class _StorageClass {
    var _join: Dialog_JoinCallRequest? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _join = source._join
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._join)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._join {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_ConnectResponse.ConnectResponseJoinCallModel, rhs: Dialog_ConnectResponse.ConnectResponseJoinCallModel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._join != rhs_storage._join {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_ConnectResponse.ConnectResponseIceCallModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_ConnectResponse.protoMessageName + ".ConnectResponseIceCallModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ice"),
  ]

  fileprivate class _StorageClass {
    var _ice: Dialog_IceCallRequest? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ice = source._ice
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._ice)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._ice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_ConnectResponse.ConnectResponseIceCallModel, rhs: Dialog_ConnectResponse.ConnectResponseIceCallModel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ice != rhs_storage._ice {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog_ConnectResponse.ConnectResponseRenegotiateCallModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Dialog_ConnectResponse.protoMessageName + ".ConnectResponseRenegotiateCallModel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
    2: .same(proto: "instanceId"),
    3: .same(proto: "peerConnectionId"),
    4: .same(proto: "sdpId"),
  ]

  fileprivate class _StorageClass {
    var _callID: String = String()
    var _instanceID: Int32 = 0
    var _peerConnectionID: Int32 = 0
    var _sdpID: SwiftProtobuf.Google_Protobuf_Int32Value? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _callID = source._callID
      _instanceID = source._instanceID
      _peerConnectionID = source._peerConnectionID
      _sdpID = source._sdpID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._callID)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._instanceID)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._peerConnectionID)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._sdpID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._callID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._callID, fieldNumber: 1)
      }
      if _storage._instanceID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._instanceID, fieldNumber: 2)
      }
      if _storage._peerConnectionID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._peerConnectionID, fieldNumber: 3)
      }
      if let v = _storage._sdpID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog_ConnectResponse.ConnectResponseRenegotiateCallModel, rhs: Dialog_ConnectResponse.ConnectResponseRenegotiateCallModel) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._callID != rhs_storage._callID {return false}
        if _storage._instanceID != rhs_storage._instanceID {return false}
        if _storage._peerConnectionID != rhs_storage._peerConnectionID {return false}
        if _storage._sdpID != rhs_storage._sdpID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
